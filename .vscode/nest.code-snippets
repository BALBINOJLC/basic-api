{
  // NEST

// Modules Standar

"Nest Create Schema": {
  "prefix": "Nest_create_schema",
  "body": [
    "import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';",
    "import { Document, Types } from 'mongoose';",

    "",
    "export const $1SchemaName = '$1';",
    "",
    "@Schema({ collection: '$2', timestamps: true })",
    "",

    "export class $1 {",
    "",
    "    @Prop({",
    "        type: String,",
    "        required: true,",
    "    })",
    "    field1: string;",
    "",
    "    @Prop({",
    "      type: String,",
    "      required: true,",
    "    })",
    "    field2: string;",
    "",
    "    @Prop({ type: Boolean, default: false })",
    "    isDeleted: boolean;",
    "",
    "    @Prop({ type: Date })",
    "    deletedAt: Date;",
    "",
    "}",

    "",
    "export type $1Document = $1 & Document;",
    "",
    "export const $1Schema = SchemaFactory.createForClass($1);"
  ]
},

"Nest Create DTO": {
  "prefix": "Nest_create_dto",
  "body": [
    "import { ApiProperty, PartialType } from '@nestjs/swagger';",
    "import { ResponseList } from '@utils';",
    "import { IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';",
    "import { $1Document } from '../schemas';",
    "",
    "export class Create$1Dto {",
    "    @IsString()",
    "    @IsNotEmpty()",
    "    @ApiProperty({",
    "        description: 'The $1 item',",
    "        example: 'What is the meaning of life?',",
    "    })",
    "    item1: string;",
    "",
    "     @IsMongoId()",
    "     @IsOptional()",
    "     @ApiProperty({",
    "         description: 'The $1 id',",
    "         example: '5e8f8f8f8f8f8f8f8f8f8f8',",
    "     })",
    "     item2: string;",
    " }",

    "export class Update$1Dto extends PartialType(Create$1Dto) {}",
    "",
    "export class Filter$1Dto {",
    "    @IsOptional()",
    "    @IsMongoId()",
    "    @ApiProperty({",
    "        description: 'The $1 id',",
    "        example: '5e8f8f8f8f8f8f8f8f8f8f8',",
    "    })",
    "    readonly _id?: string;",
    "}",

    "export class Resp$1List extends ResponseList {",
    "    data: $1Document[];",
    "}"
  ]
},

"Nest Create Controller": {
  "prefix": "Nest_create_controller",
  "body": [
    "import { Body, Controller, Delete, Get, Param, Post, Put, Query, Res, UseGuards } from '@nestjs/common';",
    "import { ApiBearerAuth, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';",
    "import { JwtAuthGuard, ParamsDto } from '@utils';",
    "import { Create$1Dto, Resp$1List, Update$1Dto, Filter$1Dto } from '../dtos';",
    "import { $1Document } from '../schemas';",
    "import { $1Service } from '../services';",
    "",
    "",
    "@ApiTags('$1')",
    "@Controller({",
    "    path: '$2',",
    "    version: '1',",
    "})",
    "",
    "   export class $1Controller {",
    "constructor(private readonly _$2Service: $1Service) {}",
    "",
    "@Get(':limit/:offset/:sort/:fields?')",
    "@ApiParam({",
    "    name: 'fields',",
    "    required: true,",
    "    description: 'If not send fields need send white space',",
    "})",
    "@ApiOperation({})",
    "@ApiBearerAuth()",
    "@UseGuards(JwtAuthGuard)",
    "async findAll(@Param() params: ParamsDto, @Query() query: Filter$1Dto, @Res() res): Promise<Resp$1List> {",
    "    try {",
    "        const resp = await this._$2Service.findAll(query, params);",
    "        return res.json(resp);",
    "    } catch (error) {",
    "        return res.status(error.code?.status || 500).json(error);",
    "    }",
    "}",
    "",
    "@Get(':fields?')",
    "@ApiParam({",
    "    name: 'fields',",
    "    required: true,",
    "    description: 'If not send fields need send white space',",
    "})",
    "@ApiOperation({})",
    "@ApiBearerAuth()",
    "@UseGuards(JwtAuthGuard)",
    "async findOne(@Query() query: Filter$1Dto, @Param('fields') fields: string, @Res() res): Promise<$1Document> {",
    "    try {",
    "        const resp = await this._$2Service.findOne(query, fields);",
    "        return res.json(resp);",
    "    } catch (error) {",
    "        return res.status(error.code?.status || 500).json(error);",
    "    }",
    "}",
    "",
    "@Post()",
    "@ApiOperation({})",
    "@ApiBearerAuth()",
    "@UseGuards(JwtAuthGuard)",
    "async create(@Body() payload: Create$1Dto, @Res() res): Promise<$1Document> {",
    "    try {",
    "        const resp = await this._$2Service.create(payload);",
    "        return res.json(resp);",
    "    } catch (error) {",
    "        return res.status(error.code?.status || 500).json(error);",
    "    }",
    "}",
    "",
    "@Put()",
    "@ApiOperation({})",
    "@ApiBearerAuth()",
    "@UseGuards(JwtAuthGuard)",
    "async update(@Body() body: Update$1Dto, @Query() query: Filter$1Dto, @Res() res): Promise<$1Document> {",
    "    try {",
    "        const resp = await this._$2Service.update( query, body);",
    "        return res.json(resp);",
    "    } catch (error) {",
    "        return res.status(error.code?.status || 500).json(error);",
    "    }",
    "}",
    "",
    "@Delete(':id')",
    "@ApiOperation({})",
    "@ApiBearerAuth()",
    "@UseGuards(JwtAuthGuard)",
    "async delete(@Param('id') id: string, @Res() res): Promise<$1Document> {",
    "    try {",
    "        const resp = await this._$2Service.delete(id);",
    "        return res.json(resp);",
    "    } catch (error) {",
    "        return res.status(error.code?.status || 500).json(error);",
    "    }",
    "}",
    "}"
  ]
},

"Nest Create Interface": {
  "prefix": "Nest_create_interface",
  "body": [
    "import { $1Document } from '../schemas';",
    "",
    "export interface IResp$1Updated {",
    "    data: $1Document;",
    "    message: string;",
    "}"
  ]

},

"Nest Create Service": {
  "prefix": "Nest_create_service",
  "body": [
    "import { HttpException, HttpStatus, Injectable } from '@nestjs/common';",
    "import { InjectModel } from '@nestjs/mongoose';",
    "import { ParamsDto } from '@utils';",
    "import { Model } from 'mongoose';",
    "import { Resp$1List, Create$1Dto, Filter$1Dto, Update$1Dto } from '../dtos';",
    "import { $1Document, $1SchemaName } from '../schemas';",
    "import { IResp$1Updated } from '../interfaces';",
    "",
    "@Injectable()",
    "export class $1Service {",
    "    constructor(",
    "        @InjectModel($1SchemaName)",
    "        private readonly model: Model<$1Document>",
    "    ) {}",
    "",
    "async create(input: Create$1Dto):Promise<$1Document> {",
    "  return new Promise<$1Document>(async (resolve, reject) => {",
    "      try {",
    "          const data = new this.model({",
    "              ...input,",
    "          });",
    "          const DB = await data.save();",
    "          resolve(DB);",
    "      } catch (err) {",
    "          const error = {",
    "              code: new HttpException('$2.ERRORS.CREATE', HttpStatus.BAD_REQUEST),",
    "              err,",
    "          };",
    "          reject(error);",
    "      }",
    "  });",
    "}",
    "",
    "async findAll(filter: Filter$1Dto, params: ParamsDto): Promise<Resp$1List> {",
    "    const query = {",
    "        ...filter,",
    "        isDeleted: false,",
    "    };",
    "    const { fields, limit, offset, sort } = params;",
    "    const newSort = JSON.parse(sort);",
    "    return new Promise<Resp$1List>(async (resolve, reject) => {",
    "        try {",
    "            let per_page = limit;",
    "            const length = await this.model.find(query).countDocuments();",
    "            const data = await this.model",
    "                .find(query, fields)",
    "                .sort({ [newSort.field]: newSort.order })",
    "                .skip(offset)",
    "                .limit(limit)",
    "                .exec();",
    "            if (length == 0) {",
    "                 resolve({",
    "                 data: [],",
    "                 page: offset,",
    "                 per_page,",
    "                 total_count: length,",
    "               });",
    "           } else {",
    "           if (limit == 0) {",
    "               per_page = length;",
    "           }",
    "}",
    "           resolve({",
    "               data,",
    "               page: offset,",
    "               per_page,",
    "               total_count: length,",
    "           });",
    "} catch (err) {",
    "    const error = {",
    "        code: new HttpException('$2.ERRORS.FIND_ALL', HttpStatus.BAD_REQUEST),",
    "        err,",
    "    };",
    "    reject(error);",
    "}",
    "});",
    "}",
    "",
    "async search(filter: Filter$1Dto, regExp: RegExp, params: ParamsDto):Promise<Resp$1List> {",
    "    const query = {",
    "        ...filter,",
    "        isDeleted: false,",
    "    };",
    "",
    "     const { sort, fields } = params;",
    "     const newSort = JSON.parse(sort);",
    "     return new Promise<Resp$1List>(async (resolve, reject) => {",
    "         try {",
    "             const length = await this.model",
    "                 .find(query, fields)",
    "                 .or([{ firstName: regExp }, { field1: regExp }, { field2: regExp }, { field3: regExp }])",
    "                 .countDocuments();",
    "",
    "             const data = await this.model",
    "                 .find(query)",
    "                 .or([{ firstName: regExp }, { lastName: regExp }, { displayName: regExp }, { email: regExp }])",
    "                 .sort({ [newSort.field]: newSort.order })",
    "                 .exec();",
    "",
    "             if (length == 0) {",
    "                 resolve({",
    "                 data: [],",
    "                 page: 0,",
    "                 per_page: length,",
    "                 total_count: length,",
    "               });",
    "           }",
    "",
    "            resolve({",
    "                data,",
    "                page: 0,",
    "                per_page: length,",
    "                total_count: length,",
    "            });",
    "        } catch (err) {",
    "            const error = {",
    "                code: new HttpException('$2.ERRORS.FIND', HttpStatus.BAD_REQUEST),",
    "                err,",
    "            };",
    "            reject(error);",
    "        }",
    "    });",
    "}",
    "",
    "async findOne(filter: Filter$1Dto, fields?: string): Promise<$1Document> {",
    "    const query = {",
    "        ...filter,",
    "        isDeleted: false,",
    "    };",
    "",
    "    return new Promise<$1Document>(async (resolve, reject) => {",
    "        try {",
    "            const data = await this.model.findOne(query, fields).exec();",
    "            if (data) {",
    "                resolve(data);",
    "            } else {",
    "                const error = {",
    "                    code: new HttpException('$2.ERRORS.NOT_FOUND', HttpStatus.NOT_FOUND),",
    "                    err: null,",
    "                };",
    "                reject(error);",
    "            }",
    "        } catch (err) {",
    "            const error = {",
    "                code: new HttpException('$2.ERRORS.FIND', HttpStatus.BAD_REQUEST),",
    "                err,",
    "            };",
    "            reject(error);",
    "        }",
    "    });",
    "}",
    "",
    "async update(filter: Filter$1Dto, input: Update$1Dto):Promise<IResp$1Updated> {",
    "    const query = {",
    "        ...filter,",
    "        isDeleted: false,",
    "    };",
    "",
    "    return new Promise<IResp$1Updated>(async (resolve, reject) => {",
    "        try {",
    "            const data = await this.model.findOneAndUpdate(query, input, { new: true });",
    "            if (data) {",
    "               resolve({",
    "                   data,", 
    "                   message: '$2.UPDATE.SUCCESS',",  
    "               });",
    "            } else {",
    "                const error = {",
    "                    code: new HttpException('$2.UPDATE.ERRORS.NOT_FOUND', HttpStatus.NOT_FOUND),",
    "                    err: null,",
    "                };",
    "                reject(error);",
    "            }",
    "        } catch (err) {",
    "            const error = {",
    "                code: new HttpException('$2.UPDATE.ERRORS.BAD_REQUEST', HttpStatus.BAD_REQUEST),",
    "                err,",
    "            };",
    "            reject(error);",
    "        }",
    "    });",
    "}",
    "",
    "async delete(id: string):Promise<{message: string}> {",
    "    return new Promise<{message: string}>(async (resolve, reject) => {",
    "        try {",
    "            const dataToDelete = await this.model.findById(id).exec();",
    "            if (dataToDelete) {",
    "                const newData = {",
    "                    uniqueField: `${dataToDelete.uniqueField}-IsDelete-${new Date().getTime()}`,",
    "                    isDeleted: true,",
    "                    deletedAt: new Date(),",
    "                };",
    "                await this.model.findByIdAndUpdate(id, newData, { new: true }).exec();",
    "                const resp = {",
    "                    message: '$2.DELETE.SUCCESS',",
    "                };",
    "                resolve(resp);",
    "            } else {",
    "                const error = {",
    "                    code: new HttpException('$2.ERRORS.NOT_FOUND', HttpStatus.NOT_FOUND),",
    "                    err: null,",
    "                };",
    "                reject(error);",
    "            }",
    "        } catch (err) {",
    "            const error = {",
    "                code: new HttpException('$2.ERRORS.UPDATE', HttpStatus.BAD_REQUEST),",
    "                err,",
    "            };",
    "            reject(error);",
    "        }",
    "    });",
    "}",
    "",
    "async have$1(filter: Filter$1Dto): Promise<$1Document> {",
    "    const query = {",
    "        ...filter,",
    "        isDeleted: false,",
    "    };",
    "    return new Promise<$1Document>(async (resolve, reject) => {",
    "        try {",
    "            const data = await this.model.findOne(query).exec();",
    "            if (data) {",
    "                resolve(data);",
    "            } else {",
    "                resolve(null);",
    "            }",
    "        } catch (err) {",
    "            const error = {",
    "                code: new HttpException('$2.ERRORS.FIND', HttpStatus.BAD_REQUEST),",
    "                err,",
    "            };",
    "            reject(error);",
    "        }",
    "    });",
    "}",
    "}"
  ]
},

"Nest Create Module": {
  "prefix": "Nest_create_module",
  "body": [
    "import { Module } from '@nestjs/common';",
    "import { $1Service } from './services';",
    "import { $1Controller } from './controllers';",
    "import { MongooseModule } from '@nestjs/mongoose';",
    "import { $1Schema, $1SchemaName } from './schemas';",
    "",
    "@Module({",
    "  imports: [",
    "    MongooseModule.forFeature([{ name: $1SchemaName, schema: $1Schema }]),",
    "  ],",
    "  providers: [$1Service],",
    "  controllers: [$1Controller],",
    "  exports: [$1Service]",
    "})",
    "export class $1Module {}"
  ]
},

"Nest Index Export Module": {
  "prefix": "Nest_index_export_module",
  "body": [
    "export * from './$1.module';",
    "export * from './controllers';",
    "export * from './services';",
    "export * from './schemas';",
    "export * from './dtos';"
  ]
}
}