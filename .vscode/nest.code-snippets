{
    // NEST

  // Modules Standar

  "Nest Create Schema": {
    "prefix": "Nest_create_schema",
    "body": [
      "import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';",
      "import { Document, Types } from 'mongoose';",

      "",
      "export const $1SchemaName = '$1';",
      "",
      "@Schema({ collection: '$2', timestamps: true })",
      "",

      "export class $1 {",
      "",
      "    @Prop({",
      "        type: String,",
      "        required: true,",
      "    })",
      "    field1: string;",
      "",
      "    @Prop({",
      "      type: String,",
      "      required: true,",
      "    })",
      "    field2: string;",
      "",
      "    @Prop({ type: Boolean, default: false })",
      "    isDeleted: boolean;",
      "",
      "    @Prop({ type: Date })",
      "    deletedAt: Date;",
      "",
      "}",

      "",
      "export type $1Document = $1 & Document;",
      "",
      "export const $1Schema = SchemaFactory.createForClass($1);"
    ]
  },

  "Nest Create DTO": {
    "prefix": "Nest_create_dto",
    "body": [
      "import { ApiProperty, PartialType } from '@nestjs/swagger';",
      "import { ResponseList } from '@utils';",
      "import { IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';",
      "import { $1Document } from '../schemas';",
      "",
      "export class Create$1Dto {",
      "    @IsString()",
      "    @IsNotEmpty()",
      "    @ApiProperty({",
      "        description: 'The $1 item',",
      "        example: 'What is the meaning of life?',",
      "    })",
      "    item1: string;",
      "",
      "     @IsMongoId()",
      "     @IsOptional()",
      "     @ApiProperty({",
      "         description: 'The $1 id',",
      "         example: '5e8f8f8f8f8f8f8f8f8f8f8',",
      "     })",
      "     item2: string;",
      " }",

      "export class Update$1Dto extends PartialType(Create$1Dto) {}",
      "",
      "export class Filter$1Dto {",
      "    @IsOptional()",
      "    @IsMongoId()",
      "    @ApiProperty({",
      "        description: 'The $1 id',",
      "        example: '5e8f8f8f8f8f8f8f8f8f8f8',",
      "    })",
      "    readonly _id?: string;",
      "}",

      "export class Resp$1List extends ResponseList {",
      "    data: $1Document[];",
      "}"
    ]
  },

  "Nest Create Controller": {
    "prefix": "Nest_create_controller",
    "body": [
      "import { Body, Controller, Delete, Get, Param, Post, Put, Query, Res, UseGuards } from '@nestjs/common';",
      "import { ApiBearerAuth, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';",
      "import { JwtAuthGuard, ParamsDto } from '@utils';",
      "import { Create$1Dto, Resp$1List, Update$1Dto, Filter$1Dto } from '../dtos';",
      "import { $1Document } from '../schemas';",
      "import { $1Service } from '../services';",
      "",
      "",
      "@ApiTags('$1')",
      "@Controller({",
      "    path: '$2',",
      "    version: '1',",
      "})",
      "",
      "   export class $1Controller {",
      "constructor(private readonly _$2Service: $1Service) {}",
      "",
      "@Get(':limit/:offset/:sort/:fields?')",
      "@ApiParam({",
      "    name: 'fields',",
      "    required: true,",
      "    description: 'If not send fields need send white space',",
      "})",
      "@ApiOperation({})",
      "@ApiBearerAuth()",
      "@UseGuards(JwtAuthGuard)",
      "async findAll(@Param() params: ParamsDto, @Query() query: Filter$1Dto, @Res() res): Promise<Resp$1List> {",
      "    try {",
      "        const resp = await this._$2Service.findAll(query, params);",
      "        return res.json(resp);",
      "    } catch (error) {",
      "        return res.status(error.code?.status || 500).json(error);",
      "    }",
      "}",
      "",
      "@Get(':fields?')",
      "@ApiParam({",
      "    name: 'fields',",
      "    required: true,",
      "    description: 'If not send fields need send white space',",
      "})",
      "@ApiOperation({})",
      "@ApiBearerAuth()",
      "@UseGuards(JwtAuthGuard)",
      "async findOne(@Query() query: Filter$1Dto, @Param('fields') fields: string, @Res() res): Promise<$1Document> {",
      "    try {",
      "        const resp = await this._$2Service.findOne(query, fields);",
      "        return res.json(resp);",
      "    } catch (error) {",
      "        return res.status(error.code?.status || 500).json(error);",
      "    }",
      "}",
      "",
      "@Post()",
      "@ApiOperation({})",
      "@ApiBearerAuth()",
      "@UseGuards(JwtAuthGuard)",
      "async create(@Body() payload: Create$1Dto, @Res() res): Promise<$1Document> {",
      "    try {",
      "        const resp = await this._$2Service.create(payload);",
      "        return res.json(resp);",
      "    } catch (error) {",
      "        return res.status(error.code?.status || 500).json(error);",
      "    }",
      "}",
      "",
      "@Put()",
      "@ApiOperation({})",
      "@ApiBearerAuth()",
      "@UseGuards(JwtAuthGuard)",
      "async update(@Body() body: Update$1Dto, @Query() query: Filter$1Dto, @Res() res): Promise<$1Document> {",
      "    try {",
      "        const resp = await this._$2Service.update( query, body);",
      "        return res.json(resp);",
      "    } catch (error) {",
      "        return res.status(error.code?.status || 500).json(error);",
      "    }",
      "}",
      "",
      "@Delete(':id')",
      "@ApiOperation({})",
      "@ApiBearerAuth()",
      "@UseGuards(JwtAuthGuard)",
      "async delete(@Param('id') id: string, @Res() res): Promise<$1Document> {",
      "    try {",
      "        const resp = await this._$2Service.delete(id);",
      "        return res.json(resp);",
      "    } catch (error) {",
      "        return res.status(error.code?.status || 500).json(error);",
      "    }",
      "}",
      "}"
    ]
  },

  "Nest Create Interface": {
    "prefix": "Nest_create_interface",
    "body": [
      "import { $1Document } from '../schemas';",
      "",
      "export interface IResp$1Updated {",
      "    data: $1Document;",
      "    message: string;",
      "}"
    ]
  
  },

  "Nest Create Service": {
    "prefix": "Nest_create_service",
    "body": [
      "import { HttpException, HttpStatus, Injectable } from '@nestjs/common';",
      "import { InjectModel } from '@nestjs/mongoose';",
      "import { ParamsDto } from '@utils';",
      "import { Model } from 'mongoose';",
      "import { Resp$1List, Create$1Dto, Filter$1Dto, Update$1Dto } from '../dtos';",
      "import { $1Document, $1SchemaName } from '../schemas';",
      "import { IRes$1Updated } from '../interfaces';",
      "",
      "@Injectable()",
      "export class $1Service {",
      "    constructor(",
      "        @InjectModel($1SchemaName)",
      "        private readonly model: Model<$1Document>",
      "    ) {}",
      "",
      "async create(input: Create$1Dto) {",
      "  return new Promise<$1Document>(async (resolve, reject) => {",
      "      try {",
      "          const data = new this.model({",
      "              ...input,",
      "          });",
      "          const DB = await data.save();",
      "          resolve(DB);",
      "      } catch (err) {",
      "          const error = {",
      "              code: new HttpException('$2.ERRORS.CREATE', HttpStatus.BAD_REQUEST),",
      "              err,",
      "          };",
      "          reject(error);",
      "      }",
      "  });",
      "}",
      "",
      "async findAll(filter: Filter$1Dto, params: ParamsDto): Promise<Resp$1List> {",
      "    const query = {",
      "        ...filter,",
      "        isDeleted: false,",
      "    };",
      "    const { fields, limit, offset, sort } = params;",
      "    const newSort = JSON.parse(sort);",
      "    return new Promise<Resp$1List>(async (resolve, reject) => {",
      "        try {",
      "            let perPage = limit;",
      "            const length = await this.model.find(query).countDocuments();",
      "            const data = await this.model",
      "                .find(query, fields)",
      "                .sort({ [newSort.field]: newSort.order })",
      "                .skip(offset)",
      "                .limit(limit)",
      "                .exec();",
      "            if (length == 0) {",
      "                 resolve({",
      "                 data: [],",
      "                 page: offset,",
      "                 per_page: perPage,",
      "                 total_count: length,",
      "               });",
      "           } else {",
      "           if (limit == 0) {",
      "               perPage = length;",
      "           }",
      "}",
      "           resolve({",
      "               data,",
      "               page: offset,",
      "               per_page: perPage,",
      "               total_count: length,",
      "           });",
      "} catch (err) {",
      "    const error = {",
      "        code: new HttpException('$2.ERRORS.FIND_ALL', HttpStatus.BAD_REQUEST),",
      "        err,",
      "    };",
      "    reject(error);",
      "}",
      "});",
      "}",
      "",
      "async search(filter: Filter$1Dto, regExp: RegExp, params: ParamsDto) {",
      "    const query = {",
      "        ...filter,",
      "        isDeleted: false,",
      "    };",
      "",
      "     const { sort, fields } = params;",
      "     const newSort = JSON.parse(sort);",
      "     return new Promise<Resp$1List>(async (resolve, reject) => {",
      "         try {",
      "             const length = await this.model",
      "                 .find(query, fields)",
      "                 .or([{ firstName: regExp }, { field1: regExp }, { field2: regExp }, { field3: regExp }])",
      "                 .countDocuments();",
      "",
      "             const data = await this.model",
      "                 .find(query)",
      "                 .or([{ firstName: regExp }, { lastName: regExp }, { displayName: regExp }, { email: regExp }])",
      "                 .sort({ [newSort.field]: newSort.order })",
      "                 .exec();",
      "",
      "             if (length == 0) {",
      "                 resolve({",
      "                 data: [],",
      "                 page: 0,",
      "                 per_page: length,",
      "                 total_count: length,",
      "               });",
      "           }",
      "",
      "            resolve({",
      "                data,",
      "                page: 0,",
      "                per_page: length,",
      "                total_count: length,",
      "            });",
      "        } catch (err) {",
      "            const error = {",
      "                code: new HttpException('$2.ERRORS.FIND', HttpStatus.BAD_REQUEST),",
      "                err,",
      "            };",
      "            reject(error);",
      "        }",
      "    });",
      "}",
      "",
      "async findOne(filter: Filter$1Dto, fields?: string): Promise<$1Document> {",
      "    const query = {",
      "        ...filter,",
      "        isDeleted: false,",
      "    };",
      "",
      "    return new Promise<$1Document>(async (resolve, reject) => {",
      "        try {",
      "            const data = await this.model.findOne(query, fields).exec();",
      "            if (data) {",
      "                resolve(data);",
      "            } else {",
      "                const error = {",
      "                    code: new HttpException('$2.ERRORS.NOT_FOUND', HttpStatus.NOT_FOUND),",
      "                    err: null,",
      "                };",
      "                reject(error);",
      "            }",
      "        } catch (err) {",
      "            const error = {",
      "                code: new HttpException('$2.ERRORS.FIND', HttpStatus.BAD_REQUEST),",
      "                err,",
      "            };",
      "            reject(error);",
      "        }",
      "    });",
      "}",
      "",
      "async update(filter: Filter$1Dto, input: Update$1Dto) {",
      "    const query = {",
      "        ...filter,",
      "        isDeleted: false,",
      "    };",
      "",
      "    return new Promise<IResp$1Updated>(async (resolve, reject) => {",
      "        try {",
      "            const data = await this.model.findOneAndUpdate(query, input, { new: true });",
      "            if (data) {",
      "               resolve({,",
      "                   data,", 
      "                   message: '$2.SUCCESS.UPDATED',",  
      "               );",
      "            } else {",
      "                const error = {",
      "                    code: new HttpException('$2.UPDATE.ERRORS.NOT_FOUND', HttpStatus.NOT_FOUND),",
      "                    err: null,",
      "                };",
      "                reject(error);",
      "            }",
      "        } catch (err) {",
      "            const error = {",
      "                code: new HttpException('$2.UPDATE.ERRORS.BAD_REQUEST', HttpStatus.BAD_REQUEST),",
      "                err,",
      "            };",
      "            reject(error);",
      "        }",
      "    });",
      "}",
      "",
      "async delete(id: string) {",
      "    return new Promise<{message: string}>(async (resolve, reject) => {",
      "        try {",
      "            const dataToDelete = await this.model.findById(id).exec();",
      "            if (dataToDelete) {",
      "                const newData = {",
      "                    uniqueField: `${dataToDelete.uniqueField}-IsDelete-${new Date().getTime()}`,",
      "                    isDeleted: true,",
      "                    deletedAt: new Date(),",
      "                };",
      "                await this.model.findByIdAndUpdate(id, newData, { new: true }).exec();",
      "                const resp = {",
      "                    message: '$2.DELETE.SUCCESS',",
      "                };",
      "                resolve(resp);",
      "            } else {",
      "                const error = {",
      "                    code: new HttpException('$2.ERRORS.NOT_FOUND', HttpStatus.NOT_FOUND),",
      "                    err: null,",
      "                };",
      "                reject(error);",
      "            }",
      "        } catch (err) {",
      "            const error = {",
      "                code: new HttpException('$2.ERRORS.UPDATE', HttpStatus.BAD_REQUEST),",
      "                err,",
      "            };",
      "            reject(error);",
      "        }",
      "    });",
      "}",
      "",
      "async have$1(filter: Filter$1Dto): Promise<$1Document> {",
      "    const query = {",
      "        ...filter,",
      "        isDeleted: false,",
      "    };",
      "    return new Promise<$1Document>(async (resolve, reject) => {",
      "        try {",
      "            const data = await this.model.findOne(query).exec();",
      "            if (data) {",
      "                resolve(data);",
      "            } else {",
      "                resolve(null);",
      "            }",
      "        } catch (err) {",
      "            const error = {",
      "                code: new HttpException('$2.ERRORS.FIND', HttpStatus.BAD_REQUEST),",
      "                err,",
      "            };",
      "            reject(error);",
      "        }",
      "    });",
      "}",
      "}"
    ]
  },

  "Nest Create Module": {
    "prefix": "Nest_create_module",
    "body": [
      "import { Module } from '@nestjs/common';",
      "import { $1Service } from './services';",
      "import { $1Controller } from './controllers';",
      "import { MongooseModule } from '@nestjs/mongoose';",
      "import { $1Schema, $1SchemaName } from './schemas';",
      "",
      "@Module({",
      "  imports: [",
      "    MongooseModule.forFeature([{ name: $1SchemaName, schema: $1Schema }]),",
      "  ],",
      "  providers: [$1Service],",
      "  controllers: [$1Controller],",
      "  exports: [$1Service]",
      "})",
      "export class $1Module {}"
    ]
  },

  "Nest Index Export Module": {
    "prefix": "Nest_index_export_module",
    "body": [
      "export * from './$1.module';",
      "export * from './controllers';",
      "export * from './services';",
      "export * from './schemas';",
      "export * from './dtos';"
    ]
  }
}